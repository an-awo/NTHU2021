# 2_1_組合語言程式語法


資料移動
- [資料移動](#資料移動 )
- [算術運算: 加法|減法|乘法|除法|移位|處理負值](#算術運算)

- [資料尋址](#資料尋址)
資料對齊|
ARRAY 陣列
改變資料的大小及類型

- [分支(Branching)與跳轉指令](#分支(Branching)與跳轉指令)
- [Looping迴圈](Looping迴圈)


- [Chapter 3: The NASM Language](https://www.nasm.us/doc/nasmdoc3.html)


```
Chapter 3: Assembly and Syntax Fundamentals
Chapter 4: Basic Instructions
Chapter 5: Intermediate Instructions
Chapter 6: Functions
```
- [哈佛大學 CS 61: Systems Programming and Machine Organization (2021)]()
- [哈佛大學課程中Assembly的介紹](https://cs61.seas.harvard.edu/site/2021/Asm/)

## 資料移動 

## 算術運算
- 算術運算: 加法|減法|乘法|除法|移位|處理負值

## 資料尋址
- See textbook 4.3.2 資料定址 
- 直接定址(direct addressing) ==> 直接使用由該識別字所代表的內存位址上的資料
- 間接定址(indirect addressing) 
-  ==> 不直接使用某個記憶體位址上的資料，
-      而是把該資料也當成位址來確定另外一個記憶體位置，轉而使用那個位置上的資料

- NASM 的變數表示的就是其記憶體位址，而不是該位址中的值
- （如果想使用這個值，要用方括號括起來，例如[sum] ）
- 範例:將變數的記憶體位址保存到另一個變數
-  MOV DWORD [sumaddr], sum
-  MDV SIZE [M]/R, M

- GAS ==> 
- 範例:將32 位元變數sum 的記憶體位址保存到 esi 寄存器
-        MOVL $sum, %esi
- 語法格式: MOVS $M, M/%R         


## bitwise operator [See textbook 5.2 按位執行的布耳運算]
- bitwise operator : NOT  AND  OR  XOR
- 應用1:加密資料
- 應用2:更新數值(比方說，把寄存器清零）

- 把al register中的十進位值與1 做AND 運算。運算的結果仍然保存在al egister
- NASM ==> AND al, Oxl


## 分支(Branching)與跳轉指令
- 無條件跳轉 <=== 無條件跳轉指令JMP
- Conditional Jump 有條件跳轉 <===  
- 複合條件

### 無條件跳轉指令JMP

- 在3 種assemblers裡的用法是一樣的。GAS/MASM/NASM
- JMP LABEL ; JMP bottom

```
top:
  mov al, 3
  add al, 5
  jmp bottom  <===無條件跳轉指令JMP

middle:
  add al, 32

bottom:
  add al, 2
```

## Conditional Jump 有條件跳轉

## C 程式片段
```
if (wages >= 50000)
   taxes = 5000
else
   taxes = 2000
```
## x86(32bit)  Program_5.1_GAS_Linux.s
```
.data
wages: .long 46000

.bss
.lcomm taxes, 4

.text
.globl _main
_main:

movl $50000, %eax
cmpl %eax, wages
jae higher
movl $2000, taxes
jmp done

higher:
movl $4000, taxes

done:
movl $1, %eax
movl $0, %ebx
int $0x80
.end
```
## x86(32bit)  Program_5.1_NASM.asm
```
SECTION .data
wages: DD 46000

SECTION .bss
taxes: RESD 1

SECTION .text
global _main
_main:

 mov eax, 50000
 cmp DWORD [wages], eax
 jae higher
 mov DWORD [taxes], 2000
 jmp done

higher:
 mov DWORD [taxes], 4000

done:
mov eax, 1
mov ebx, 0
int 80h
```
## x86_64  Program_5.1_GAS_Linux.s
```
.data
wages: .quad 46000

.bss
.lcomm taxes, 8

.text
.global _main
_main:

movq $50000, %rax
cmpq %rax, wages(%rip)
jae higher
movq $2000, taxes(%rip)
jmp done

higher:
movq $4000, taxes(%rip)

done:
movq $60, %rax
xorq %rdi, %rdi
syscall
.end
```
## x86_64  Program_5.1_NASM.asm
```
SECTION .data 
wages: DQ 46000

SECTION .bss
taxes: RESQ 1

SECTION .text 
global _main
_main:

mov rax, 50000
cmp QWORD [wages], rax 
jae higher
mov QWORD [taxes], 2000 
jmp done

higher:
mov QWORD [taxes], 4000

done:
mov rax, 60
xor rdi, rdi
syscall
```

## Looping迴圈
```c
for (int x = 0; x < 10; x++)
     Sequence of instructions
```
```c
while (answer == "yes")
     Sequence of instructions
```
- 使用CX/ECX/RCX 计数器实现循环
- LOOP 指令在3 種assemblers中是相同的，都需要帶有標籤[GAS/MASM/NASM]
-  LOOP LABEL ; 

## x86(32bit) gas
```
.text
.globl _main
_main:

xorl %eax, %eax   ==> 通過bitwise XOR 指令把eax 寄存器的值設置成0, 這種做法在彙編代碼中經常用來歸零
movl $5, %ecx

myLoop:                        
   incl %eax
   loop myLoop

movl $1, %eax
movl $0, %ebx
int $0x80
.end
```
## x86(32bit) nasm
```
SECTION .text
global _main
_main:

xor eax, eax  ==> 通過bitwise XOR 指令把eax 的值設置成0, 這種做法在assembly program中經常用來歸零
mov ecx, 5

myLoop:
  inc eax
  loop myLoop

mov eax, 1
mov ebx, 0
int 80h
```
## x86_64 gas
```
.text
.global _main
_main:

xor %rax, %rax   ==> 通過bitwise XOR 指令把rax 寄存器的值設置成0, 這種做法在彙編代碼中經常用來歸零
mov $5, %rcx

myLoop:
   inc %rax      ===> 總共要執行迴圈5 次，每次都要給rax 加 1, 因此它的最終值是5
   loop myLoop

執行到LOOP 指令時，程式會自動做:
[1]把rcx 寄存器的值減I
[2]判斷它是否不等於0
如果不等於0==>跳到LOOP 指令所指定的標籤
如果等於0 ==>開始執行LOOP 下方的那條指令。

mov $60, %rax
xor %rdi, %rdi
syscall
.end
```
## x86_64 nasm
```
.text
.global _main
_main:

xor %rax, %rax  ==> 通過bitwise XOR 指令把rax 寄存器的值設置成0, 這種做法在彙編代碼中經常用來歸零
mov $5, %rcx

myLoop:
   inc %rax
   loop myLoop

mov $60, %rax
xor %rdi, %rdi
syscall
.end
```
# Program 5.3 Nested for Loop

## x86(32bit) gas
```
.text
.globl _main
_main:

xorl %eax, %eax
movl $2, %ebx
outer:
    movl $3, %ecx
    inner:
        incl %eax
        decl %ecx
        cmpl $0, %ecx
        jne inner
    decl %ebx
    cmpl $0, %ebx
    jne outer

movl $1, %eax
movl $0, %ebx
int $0x80
.end
```
## x86(32bit) nasm
```
SECTION .text
global _main
_main:

xor eax, eax
mov ebx, 2
outer:
   mov ecx, 3
      inner:
      inc eax
      dec ecx
      cmp ecx, 0
      jne inner
   dec ebx
   cmp ebx, 0
   jne outer

mov eax, 1
mov ebx, 0
int 80h
```
## x86_64 gas
```
.text
.global _main
_main:

xorq %rax, %rax
movq $2, %rbx
outer:
    movq $3, %rcx
    inner:
        incq %rax
        decq %rcx
        cmpq $0, %rcx
        jne inner
    decq %rbx
    cmpq $0, %rbx
    jne outer

movq $60, %rax
xorq %rdi, %rdi
syscall
.end
```
## x86_64 nasm
```
SECTION .text
global _main
_main:

xor rax, rax
mov rbx, 2
outer:
   mov rcx, 3
      inner:
      inc rax
      dec rcx
      cmp rcx, 0
      jne inner
   dec rbx
   cmp rbx, 0
   jne outer

mov rax, 60
xor rdi, rdi
syscall
```
# Program 5.4 while Loop
## x86(32bit) gas
```
.text
.globl _main
_main:

movl $30, %eax
while_loop:
    cmpl $50, %eax
    jae done
    incl %eax
    jmp while_loop
done:

movl $1, %eax
movl $0, %ebx
int $0x80
.end
```
## x86(32bit)  nasm
```
SECTION .text
global _main
_main:

mov eax, 30
while_loop:
   cmp eax, 50
   jae done
   inc eax
   jmp while_loop
done:

mov eax, 1
mov ebx, 0
int 80h
```
## x86_64  gas
```
.text
.global _main
_main:

movq $30, %rax
while_loop:
    cmpq $50, %rax
    jae done
    incq %rax
    jmp while_loop
done:

movq $60, %rax
xorq %rdi, %rdi
syscall
.end
```
## x86_64  nasm
```
SECTION .text
global _main
_main:

mov rax, 30
while_loop:
   cmp rax, 50
   jae done
   inc rax
   jmp while_loop
done:

mov rax, 60
xor rdi, rdi
syscall
```
