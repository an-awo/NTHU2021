# 2_1_組合語言程式語法


- [資料型態](#資料型態)
- [資料移動](#資料移動 )
- [算術運算: 加法|減法|乘法|除法|移位|處理負值](#算術運算)

- [資料尋址](#資料尋址)
- [資料對齊](#資料對齊)
- [ARRAY陣列](#ARRAY陣列)
- [string字串](#string字串)

改變資料的大小及類型

- [分支(Branching)與跳轉指令](#分支(Branching)與跳轉指令)
- [Looping迴圈](Looping迴圈)


###  參考資料
- [Assembly Programming and Computer Architecture for Software Engineers(2017)](https://www.prospectpressvt.com/textbooks/hall-assembly-programming-and-computer-architecture-for-software-engineers) [[簡中譯本:匯編程序設計與電腦體系結構：軟件工程師教程]](https://www.tenlong.com.tw/products/9787111615163) [GITHUB(原始碼)](https://github.com/brianrhall/Assembly)
  - Chapter 3: Assembly and Syntax Fundamentals
  - Chapter 4: Basic Instructions
  - Chapter 5: Intermediate Instructions
  - Chapter 6: Functions
  - Chapter 7: String Instructions & Structures
- [哈佛大學 CS 61: Systems Programming and Machine Organization (2021)]()
- [哈佛大學課程中Assembly的介紹(gas)](https://cs61.seas.harvard.edu/site/2021/Asm/)
- [Chapter 3: The NASM Language](https://www.nasm.us/doc/nasmdoc3.html)

## 資料型態
- see textbook Chapter 1: Data Representation see Table 1.4 Integer storage sizes
- Number Systems:
- Integer Storage ==> byte | word | doubleword |quadword
- most significant bit (MSB) and least significant bit (LSB)
- Little-Endian vs Big-Endian byte order
  - Computers typically store data in memory in architecture-specific chunks (32 and 64 bits for x86 and x86_64, respectively), with values being composed of bytes. 
  - If we were to store the 32-bit hexadecimal value 12345678h into a computer’s memory, the 32-bit value is split into byte-sized chunks,
  - each hexadecimal digit is four bits, so two hexadecimal digits are one byte.



  - Intel’s x86 and x86_64 use Little-Endian ordering. 
  - Motorola’s 68XX[X] series processors, along with IBM’s Z series, use Big-Endian ordering. 
  - Some processors can use either, coined bi-endian, such as the Sun SPARC, ARM, and PowerPC

- Signed Integer Storage
  - Three of the basic arithmetic operations are forms of addition: (1) addition, (2) subtraction (adding a negative value), and (3) multiplication (repetitive addition). -  
  - Therefore, many CPU circuits are addition circuits
  - one’s complement, and two’s complement. 
  - In all three methods, the MSB indicates positive (0) or negative(1). 
  - Many modern architectures, such as x86 and x86_64, use two’s complement for signing integers

- Character Storage
  - character sets ==> [ASCII](https://en.wikipedia.org/wiki/ASCII) is the default character map for high-level languages such as C++. 

- [A 3-bit Computer Example](https://www.youtube.com/watch?v=gYczcmDywag)

- [buuble sort: assembly program vs C program](https://github.com/brianrhall/Assembly/tree/master/Chapter_1)




## 資料移動 

## 算術運算
- 算術運算: 加法|減法|乘法|除法|移位|處理負值

## 資料尋址
- See textbook 4.3.2 資料定址 
- 直接定址(direct addressing) ==> 直接使用由該識別字所代表的內存位址上的資料
- 間接定址(indirect addressing) 
-  ==> 不直接使用某個記憶體位址上的資料，
-      而是把該資料也當成位址來確定另外一個記憶體位置，轉而使用那個位置上的資料

- NASM 的變數表示的就是其記憶體位址，而不是該位址中的值
- （如果想使用這個值，要用方括號括起來，例如[sum] ）
- 範例:將變數的記憶體位址保存到另一個變數
-  MOV DWORD [sumaddr], sum
-  MDV SIZE [M]/R, M

- GAS ==> 
- 範例:將32 位元變數sum 的記憶體位址保存到 esi 寄存器
-        MOVL $sum, %esi
- 語法格式: MOVS $M, M/%R         

## Boolean Expressions
- AND OR NOT XOR
- see Table 1.7 Boolean symbols
- 應用 ==> see Example 1.19 Masking

## bitwise operator [See textbook 5.2 按位執行的布耳運算]
- bitwise operator : NOT  AND  OR  XOR
- 應用1:加密資料
- 應用2:更新數值(比方說，把寄存器清零）

- 把al register中的十進位值與1 做AND 運算。運算的結果仍然保存在al egister
- NASM ==> AND al, Oxl


## 分支(Branching)與跳轉指令
- 無條件跳轉 <=== 無條件跳轉指令JMP
- Conditional Jump 有條件跳轉 <===  
- 複合條件

### 無條件跳轉指令JMP

- 在3 種assemblers裡的用法是一樣的。GAS/MASM/NASM
- JMP LABEL ; JMP bottom

```
top:
  mov al, 3
  add al, 5
  jmp bottom  <===無條件跳轉指令JMP

middle:
  add al, 32

bottom:
  add al, 2
```

## Conditional Jump 有條件跳轉

## C 程式片段
```
if (wages >= 50000)
   taxes = 5000
else
   taxes = 2000
```

## x86(32bit)  Program_5.1_NASM.asm
```
SECTION .data
wages: DD 46000

SECTION .bss
taxes: RESD 1

SECTION .text
global _main
_main:

 mov eax, 50000
 cmp DWORD [wages], eax
 jae higher
 mov DWORD [taxes], 2000
 jmp done

higher:
 mov DWORD [taxes], 4000

done:
mov eax, 1
mov ebx, 0
int 80h
```

## x86_64  Program_5.1_NASM.asm
```
SECTION .data 
wages: DQ 46000

SECTION .bss
taxes: RESQ 1

SECTION .text 
global _main
_main:

mov rax, 50000
cmp QWORD [wages], rax 
jae higher
mov QWORD [taxes], 2000 
jmp done

higher:
mov QWORD [taxes], 4000

done:
mov rax, 60
xor rdi, rdi
syscall
```

## Looping迴圈
```c
for (int x = 0; x < 10; x++)
     Sequence of instructions
```
```c
while (answer == "yes")
     Sequence of instructions
```
- 使用CX/ECX/RCX 计数器实现循环
- LOOP 指令在3 種assemblers中是相同的，都需要帶有標籤[GAS/MASM/NASM]
-  LOOP LABEL ; 

## x86(32bit) nasm
```
SECTION .text
global _main
_main:

xor eax, eax  ==> 通過bitwise XOR 指令把eax 的值設置成0, 這種做法在assembly program中經常用來歸零
mov ecx, 5

myLoop:
  inc eax
  loop myLoop

mov eax, 1
mov ebx, 0
int 80h
```

## x86_64 nasm
```
.text
.global _main
_main:

xor %rax, %rax  ==> 通過bitwise XOR 指令把rax 寄存器的值設置成0, 這種做法在彙編代碼中經常用來歸零
mov $5, %rcx

myLoop:
   inc %rax      ===> 總共要執行迴圈5 次，每次都要給rax 加 1, 因此它的最終值是5
   loop myLoop

;執行到LOOP 指令時，程式會自動做:
;[1]把rcx 寄存器的值減I
;[2]判斷它是否不等於0
;如果不等於0==>跳到LOOP 指令所指定的標籤
;如果等於0 ==>開始執行LOOP 下方的那條指令。

mov $60, %rax
xor %rdi, %rdi
syscall
.end
```
# Program 5.3 Nested for Loop


## x86(32bit) nasm
```
SECTION .text
global _main
_main:

xor eax, eax
mov ebx, 2
outer:
   mov ecx, 3
      inner:
      inc eax
      dec ecx
      cmp ecx, 0
      jne inner
   dec ebx
   cmp ebx, 0
   jne outer

mov eax, 1
mov ebx, 0
int 80h
```

## x86_64 nasm
```
SECTION .text
global _main
_main:

xor rax, rax
mov rbx, 2
outer:
   mov rcx, 3
      inner:
      inc rax
      dec rcx
      cmp rcx, 0
      jne inner
   dec rbx
   cmp rbx, 0
   jne outer

mov rax, 60
xor rdi, rdi
syscall
```
# Program 5.4 while Loop

## x86(32bit)  nasm
```
SECTION .text
global _main
_main:

mov eax, 30
while_loop:
   cmp eax, 50
   jae done
   inc eax
   jmp while_loop
done:

mov eax, 1
mov ebx, 0
int 80h
```

## x86_64  nasm
```
SECTION .text
global _main
_main:

mov rax, 30
while_loop:
   cmp rax, 50
   jae done
   inc rax
   jmp while_loop
done:

mov rax, 60
xor rdi, rdi
syscall
```
